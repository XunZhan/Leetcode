/********************************************************************************************
 *
 * Detailed Solutions Could be Found in Problem -> Solution
 *
 ********************************************************************************************/


/********************************************************************************************
 * 1. Brute-force
 *
 * Time:  O(N^2)
 * Space: O(1)
********************************************************************************************/



/********************************************************************************************
2. Two Pass Map
 *
 *
 * Time: O(N)
 * Space O(N)
 ********************************************************************************************/



/********************************************************************************************
 3. Set + Math
 *
 * Example: [1,2,2,4]:
 *      In the set, we get sum: 1+2+4 = 7. -> Detect dup.
 *      Expected sum: 1+2+3+4 = 10. -> Detect miss. miss = 10 - 7.
 *
 * Time: O(N)
 * Space O(N)
 ********************************************************************************************/



/********************************************************************************************
 3. Two Pass Bitwise
 *
 * We know x^x = 0, x^y^x^x^y = x.
 * Example: [1,2,2,4,5]:
 *      1^1 ^ 2^2 ^ 2^3 ^ 4^4 ^ 5^5 = 2^3 = dup ^ miss
 *      BUT we ONLY know a number = dup ^ miss, we need to seperate it.
 *
 * Time: O(N)
 * Space O(1)
 ********************************************************************************************/
class Solution {
    public int[] findErrorNums(int[] nums) {

        int xor = 0;
        for (int i = 0; i<nums.length; i++)
        {
            xor ^= nums[i] ^ (i+1);
        }

        int rightMost = xor & ~(xor - 1);
        int xor1 = 0, xor2 = 0;
        for (int i = 0; i< nums.length; i++)
        {
            if ((int)(nums[i] & rightMost) != 0 )
                xor1 ^= nums[i];
            else
                xor2 ^= nums[i];

            if ((int)((i+1) & rightMost) != 0)
                xor1 ^= (i+1);
            else
                xor2 ^= (i+1);
        }

        for (int i = 0; i< nums.length; i++)
        {
            if (xor2 == nums[i])
                return new int[] {xor2, xor1};
        }
        return new int[] {xor1, xor2};
    }
}